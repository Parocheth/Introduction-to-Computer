# 2.1 仿真与二进制
起草人：李木星  审阅人：李木星


   1. 仿真与二进制
       i. 什么是仿真？
 
       仿真————就是用模型（物理模型或数学模型）代替实际系统进行试验和研究。

       例如：按键控制8X8LED点阵屏显示图形    /*
 名称：按键控制8X8LED点阵屏显示图形  
说明：每次按下K1时，会使8X8LED点阵屏循环显示不同图形。   
  本例同时使用外部中断和定时中断。 */  
#include<reg51.h>
 #include<intrins.h> 
 #define uchar unsigned char 
#define uint unsigned int //待显示图形编码 
ucha
 code
 M[][8]= {  {0x00,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x00},  
  {0x00,0x38,0x44,0x54,0x44,0x38,0x00,0x00},
    {0x00,0x20,0x30,0x38,0x3c,0x3e,0x00,0x00}
   }; 
 uchar i,j; //主程序 
void main() 
{
  P0=0xff;
  P1=0xff;
      TMOD=0x01;    //T0方式1 
TH0=(65536-2000)/256; //2ms定时 
 TL0=(65536-2000)%256;
  IT0=1;   //下降沿触发 
 IE=0x83;   //允许定时器0、外部0中断 
 i=0xff;   
 //i的初值设为0xff，加1后将从0开始  
while(1)；
 }  //T0中断控制点阵屏显示  
void Show_Dot_Matrix()
 interrupt 1 
{
  TH0=(65536-2000)/256; //恢复初值  
TL0=(65536-2000)%256;
  P0=0xff;    //输出位码和段码  
P0=~M[i][j];
  P1=_crol_(P1,1);   
j=(j+1)%8;
 }  //INT0中断（定时器由键盘中断启动） 
void Key_Down()
 interrupt 0 
{  
P0=0xff;
  P1=0x80;
  j=0;
  i=(i+1)%3;    //i在0，1，2中取值，因为只要3个图形
  TR0=1;
 }
    P0=SBUF;  //接收到的数据显示在P0口，显示拨码开关的值    
DelayMS(20);
  }
 }       甲机通过串口控制乙机LED    /* 名称：甲机发送控制命令字符  说明：甲单片机负责向外发送控制命令字符“A”、“B”、“C”，或者停止发送，乙机根据所接收到的字符完成LED1闪烁、LED2闪烁、双闪烁、或停止闪烁。 */  
#include<reg51.h>  
#define uchar unsigned char 
#define uint unsigned int sbit LED1=P0^0;
   sbit LED2=P0^3;
 sbit K1=P1^0; //延时
  void DelayMS(uint ms)
 {
  uchar i;
  while(ms--) 
for(i=0;i<120;i++);
 }  //向串口发送字符
  void Putc_to_SerialPort(uchar c)
 {  SBUF=c;
  while(TI==0);
  TI=0; 

}  //主程序 
void main()
 {
  uchar Operation_No=0;
  SCON=0x40;  //串口模式1  
TMOD=0x20;  //T1工作模式2  
PCON=0x00;  //波特率不倍增  
TH1=0xfd;
  TL1=0xfd;
  TI=0;
  TR1=1;
  while(1)
  {
   if(K1==0) //按下K1时选择操作代码0，1，2，3   
{
    while(K1==0);
    Operation_No=(Operation_No+1)%4;
   }
   switch(Operation_No) //根据操作代码发送A/B/C或停止发送
   {
    case 0: LED1=LED2=1; 
     break;   
case 1: Putc_to_SerialPort('A');      
LED1=~LED1;
LED2=1;      
break;   
 case 2: Putc_to_SerialPort('B');
      LED2=~LED2;
LED1=1;
      break;
    case 3: Putc_to_SerialPort('C');
          LED1=~LED1;
LED2=LED1;
      break;
   }
   DelayMS(100);
  }
 }     /* 名称：乙机程序接收甲机发送字符并完成相应动作
  说明：乙机接收到甲机发送的信号后，根据相应信号控制LED完成不同闪烁动作。
 */ 
 #include<reg51.h>  #define uchar unsigned char #define uint unsigned int sbit LED1=P0^0;
              ————摘自百度
        
        ii.二进制源码，反码与补码之间的区别
           以8位二进制为例,
正数的原码、反码、补码相同,
负数的反码为：除符号位外,原码各位取反,反码加1,得负数的反码.

下面就对于原码，反码，补码详细分析一下：

原码：将一个整数，转换成二进制，就是其原码。如单字节的5的原码为：0000 0101；-5的原码为1000 0101。

反码：正数的反码就是其原码；负数的反码是将原码中，除符号位以外，每一位取反。如单字节的5的反码为：0000 0101；-5的反码为1111 1010。

补码：正数的补码就是其原码；负数的反码+1就是补码。如单字节的5的补码为：0000 0101；-5的原码为1111 1011。

在计算机中，正数是直接用原码表示的，如单字节5，在计算机中就表示为：0000 0101。
负数用补码表示，如单字节-5，在计算机中表示为1111 1011。
    正数的原码、补码和反码相同。负数的反码等于原码按位取反，补码等于反码加1。
                  ——-——摘自百度
                         iii.十进制数与二进制是相互转换的规则  
      
 我们日常生活中常用的数制是十进制数，即0~9，全部数码的个数是10也称为基数，十进制的进位原则为：逢基数10进位，在不同位上的数码代表不同的数值，这与它的权有关，位权等于基数的次幂数，即各位的位权为10^0；十为的位权为10^1；百为的位权为10^2…而十分为的位权为10^(-1)；百分位上的位权为：10^(-2)。
       二进制变十进制

转换原则：把二进制数写成按权展开的多项式加法，然后求和，即可将二进制转化为十进制数。

      十进制变为二进制
进制的整数部分和小数部分分别用不同的方法进行转换
1.整数部分转换原则：除2取余法，将所得余数倒着写。即将十进制数反复除以2，取余数，直到商为0为止，最后将所得余数倒着排列，即为十进制数转换为二进制数。
二进制数与十进制之间的相互转换
2.小数部分的转换原则：乘2取整法，顺着写，即将十进制小数部分不断  乘以2取整，直到小数位零，或到达有效精度为止，最先得到的数位最高位，最后得到的整数位最低位。
   注意十进制转换为二进制时，整数部分和小数部分的转换原则是不一样的。
    
          -——--摘自百度
